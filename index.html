<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algoritma</title>
  </head>
  <body>
    <h1>ALGORİTMA KONULARI</h1>
    <p>
      Stack, LIFO (Last in First out) (En son giren en önce çıkar) mantığına
      dayanan, elemanlar topluluğundan oluşan bir yapıdır. Gelin hemen
      örneğimize geçelim. Taşınırken topladığınız koli kutusu düşünün.
      İçerisinde kitaplar var ve en, boy olarak koliye tam olarak koyuluyor.
      Mantıken kolinin altı kapalı ve üst üste koymanız gerekmektedir. Yeni
      taşındığınız yerde çıkartırken en üstekinden başlarsınız. İşte stack
      (Yığın) da aynı mantıkta çalışıyor. Yığınlara eleman eklerken veya
      çıkartırken bazı methodlar uygulanır. Bunlardan biri push, diğeri ise pop.
      Push, yığının üzerine eleman eklemek için kullanılır (Koliye kitap
      koymak). Pop ise, yığından eleman çıkarmak için kullanılır.
    </p>
    <p>
      Queue (Kuyruk), FIFO (First in First out) (İlk giren ilk çıkar) prensibine
      dayanan, girişlerde ve çıkışlarda belirli bir kurala göre çalışan yapıdır.
      Stack de verdiğimiz örneği kuyruğa göre uyarlayalım. Biz örnekte altı
      kapalı bir koli kutusunu düşünmüştük. Şimdi o koli kutusunun altı
      yırtılmış. Sonuç olarak ne oluyor? İlk giren ilk çıkmış oluyor. Queue
      (Kuyruk)'da eleman eklemesi yaparken enqueue methodunu kullanıyoruz.
      Eleman silerken ise dequeue methodunu kullanıyoruz.
    </p>
    <p>
      Hash Function/ Hash Table Indexleme Arraylerde 0 bazlı bir indexleme
      vardır. Bazı programlama dillerin 1 bazlı indexlemeler olsa da genel
      olarak 0 bazlı indexleme kullanılır. Indexleme Hash Function/ Hash Table
      Hash Table, key value prensibine dayanan bir array kümesidir. Key olarak
      çağırdığınız elemanın değerini (value) yansıtır. Hash Table yerine
      dizileri kullanabilirdik. Fakat her ürünü ve fiyatını tek tek aramak
      istemediğimiz için hash table kullanıyoruz. Peki bu süreç nasıl işliyor?
      Hemen bir örnek yapalım. Örneğimiz bir kuru yemiş dükkanından gelecek.
      örnek-ilk-kısım Bu kısımda ilk olarak bulunan ürün sayımız kadar değeri
      olan bir Array oluşturduk. Daha sonra hash fonksiyonundan ürünleri
      geçirerek index değerlerine ulaştık. örnek-ikinci-kısım Şifrelendiği için
      artık her badem keyi gönderildiğinde 85TL, fıstık keyi gönderildiğinde ise
      69 sonucu verecektir. Özetle, elimizde var olan verileri bir fonksiyondan
      geçirip indexliyoruz. Bu fonksiyona hash function, bu fonksiyon ile
      birleştiğimiz dizi yapısına ise Hash Table diyoruz.
    </p>
    <p>
      Algoritma Analizi Algoritma analizi, var olan kaynaklara göre en uygun
      algoritmayı seçmek için uygulanır. Peki algoritma analizi en iyi nasıl
      yapılır? Kulağa karmaşık geliyor ama çok basit. Programlama dillerinden ve
      donanımlardan bağımsız bir şekilde Algoritma analizi yapılmalıdır. Aksi
      taktirde en uygun sonuç alınamayabilir. Donanımlar veya programlama
      dilleri farklı cihazlarda aynı performansı vermeyebilir. Örnek verecek
      olursak, cep telefonları için uygulama tasarladığımızı varsayalım. Bu
      uygulamanın performansı Apple telefonlar için farklı, Android telefonlar
      için farklı, arasında donanım farklı olanlar için ayrı olacaktır. Donanım
      ve diller ile algoritma analizi pek sağlıklı değildir. Algoritma analizi,
      bir algoritmanın çalışabilmesi için gerekli koşulların sağlanıp
      sağlanamadığını gösteren bir parametredir.
    </p>
    <p>
      Selection Sort En basit sorting algoritmalarından biridir. insertion-sort
      Verilen örüntüye ait en küçük elemanı buluyor ve en baştaki sayı ile yer
      değiştiriyor. Peki ya devamı? İkinci en küçük elemanı buluyor ve 2. sıra
      ile değiştiriyor. Baktın ki 2.sıradaki eleman en küçük hiç dokunma!!!.
      Hemen 3. sıraya geç. 4, 5 derken dizi bitti. İşte insertion sort'un temel
      çalışma prensibini öğrendin. big-o-insertion
    </p>
    <p>
      Merge Sort Insertion Sort'da, Big-O gösteriminden dolayı input'um
      arttığında n2 olduğunda dolayı çalışma zamanı artıyor. Peki daha hızlı bir
      şekilde sıralama yapılabilir mi? Evet, Merge Sort burada yardımımıza
      koşuyor. Bir listeyi her adımda parçaya ayırıp tek eleman kalıncaya kadar
      bölüyor. Böldükten sonra sıralı bir şekilde bize sunuyor (Performans).
      merge-sort big-o-merge Insertion sort'da, time complexity n2 olduğundan
      ötürü çalışma zamanımız artıyordu. Merge sort'da ise nlogn olduğu için
      açık ara performans olarak daha iyi diyebiliriz.
    </p>
    <p>
      Quick Sort Hızlı sıralama günümüzde çok yaygın olarak kullanılan bir
      sıralama algoritmasıdır. N tane sayıyı average case e göre big-o nlogn,
      worst case e göre big-o n^2 karmaşıklığı ile sıralanır. QuickSort İlk
      olarak bir pivot belirler bu pivota göre pivottan küçük ve eşitler sol
      kısmına, pivottan büyük ve eşitler sağ kısmına yazılır. Parçalanmış
      kısımlar yeni bir pivot belirlenerek parça pinçik edilir.
    </p>
    <p>
      Linear Search Linear search, tek tek elemanları dolandıktan sonra
      istediğim elemanın olup olmadığına bakmaktır. Örneğin, [20,25,46,48] veri
      setini ele alalım. Benim aradığım eleman 25. İlk elemana gidiyorum ve
      değeri 20 sen değilsin diyorum. İkinci elemana gidiyorum ve değeri 25 evet
      sensin diyorum. Linear search algoritmam burada bitmiş oluyor. Big-o ya
      göre incelediğimizde bizim worst case'imiz neydi? Elemanın dizinin sonunda
      bulunmasıydı. Bu sebepten ötürü n elemanımız varsa big-o notasyonumuz
      otomatik olarak n oluyor.
    </p>
    <p>
      Binary Search İkili arama algoritması, elimizde bulunan veri dizisini
      sıralı olduğunu varsayıyor, bu durumu değiştirerek sonuca varmak istiyor.
      İkili arama algoritması, diziyi her seferinde ikiye bölerek ikili arama
      yapar. Sıralı bir listem var ise benim Big-o logn olarak karşımıza
      çıkıyor. Aradığım sayı 15 ve benim değer kümem [10,15,20,16,22,36,23]
      diyelim. Binary Search bu diziyi manipüle ederek şu ifadeye dönüştürüyor.
      [10,15,16,20,22,23,36]. 36 sayısını en yüksek sayı, 10 sayısını en düşük
      sayı ilan ediyor. Benim aradığım sayı ile ortada kalan sayıyı kıyaslıyor
      eğer benim sayım büyükse kendinden küçük bütün sayıları siliyor. Ve
      kendine yeni bir ortanca belirliyor. Böylelikle gereksiz arama yapmaktan
      kurtarıyor.
    </p>
  </body>
</html>
